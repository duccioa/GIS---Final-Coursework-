{
    "contents" : "library(sp)\n\nextract.areas <- function(sp){\n    n <- length(sp@polygons)\n    areas <- rep(0, n)\n    for(i in 1:n){\n        areas[i] <- sp@polygons[i][[1]]@Polygons[[1]]@area\n    }\n    return(areas)\n}\n#1#\n#creates the matrix V with coordinates x1,y1,x2,y2 of each segment of the polygon\nfetch.lines <- function(sp, i){\n    coords <- sp@polygons[i][[1]]@Polygons[[1]]@coords#extract the coordinates of the vertex\n    n <- nrow(coords)\n    coords <- coords[n:1, ]\n    v <- cbind(coords[1:(n-1),], coords[2:n,])\n    return(v)\n}\n##########################################################################################\n#2#\n#Given one vector with coordinates x1,y1,x2,y2 the function return\n#Areas and MI of the triangle and rectangle for the line between the two vertex\n#v[1]=x1\n#v[2]=y1\n#v[3]=x2\n#v[4]=y2\n#To be applied to matrix V\n#Caclulate area\ncalc.A_tr <- function(v){\n    A_tr <- (v[3]-v[1])*(v[4]-v[2])/2#area of the triangle\n    return(A_tr)\n}\ncalc.A_rec <- function(v){\n    A_rec <- (v[3]-v[1])*v[2]#area of the rectangle\n    return(A_rec)\n}\n##########################################################################################\n#3#\n#calculate x_g and y_g coordinates\n#specify the required coordinate \"x\" or \"y\"\n#specify the shape \"tri\" or \"rec\"\ncalc.coords_g <- function(v, x_or_y = \"x\", shape = \"tri\"){\n    if(x_or_y == \"x\"){\n        if(shape == \"tri\"){return((v[1]+2*v[3])/3)}#centroid's x_gt of the triangle\n        if(shape == \"rec\"){return((v[2]+2*v[4])/3)}#centroid's y_gt of the triangle    \n    }\n    if(x_or_y == \"y\"){\n        if(shape == \"tri\"){return((v[1]+v[3])/2)}#centroid's x_gr of the rectangle\n        if(shape == \"rec\"){return(v[2]/2)}#centroid's y_gr of the rectangle\n    }\n}\n##########################################################################################\n#4#\n#calculate MI\ncalc.I_tr <- function(v, Area){Area*((v[3]-v[1])^2 + (v[2]-v[4])^2)/18}#I_tr\n\ncalc.I_rec <- function(v, Area){Area*((v[3]-v[1])^2 + v[2])/12}#I_rec\n##########################################################################################\n\n#5#\n#Create dataframe to df_MI used to perform the final calculation of the MIg\ncreate.df <- function(V){\n    A_tr <- apply(V, 1, calc.A_tr)#Area triangle\n    A_rec <- apply(V, 1, calc.A_rec)#Area rectangle\n    x_gt <- apply(V, 1, calc.coords_g, x_or_y = \"x\", shape = \"tri\")#x coords of the triangle's centroid\n    y_gt <- apply(V, 1, calc.coords_g, x_or_y = \"y\", shape = \"tri\")\n    x_gr <- apply(V, 1, calc.coords_g, x_or_y = \"x\", shape = \"rec\")\n    y_gr <- apply(V, 1, calc.coords_g, x_or_y = \"y\", shape = \"rec\")\n    I_tr <- calc.I_tr(V, Area = A_tr)#MI of the triangle about its centroid\n    I_rec <- calc.I_rec(V, Area = A_rec)\n    V_df <- data.frame(line_ID = seq(1, nrow(V)), cbind(V, x_gt, y_gt, A_tr, I_tr, x_gr, y_gr, A_rec, I_rec))\n    names(V_df)[2:5] <- c(\"x1\", \"y1\", \"x2\", \"y2\")\n    A <- sum(A_tr + A_rec)#total area triangle and rectangle\n    x_g <- sum((x_gr*A_rec + x_gt*A_tr)/A)#x coords of the polygon's centroid\n    y_g <- sum((y_gr*A_rec + y_gt*A_tr)/A)\n    V_df$Dist_tr <- sqrt((x_g - x_gt)^2 + (y_g - y_gt)^2)#distance \n    V_df$Dist_rec <- sqrt((x_g - x_gr)^2 + (y_g - y_gr)^2)\n    return(V_df)\n}\n##########################################################################################\n#6#\ncalc.Cmi_index <- function(V_df, A_pol){\n    Ig <- with(V_df, sum(I_tr + A_tr*(Dist_tr^2) + I_rec + A_rec*(Dist_rec^2)))\n    C_mi <- (A_pol^2)/(2*pi*Ig) \n    return(C_mi)\n}\n##########################################################################################\n##########################################################################################\n\nPolygon.Cmi_index <- function(sp, i){\n    Area_polygon <- sp@polygons[i][[1]]@Polygons[[1]]@area\n    V_matrix <- fetch.lines(sp, i)\n    V_polygon <- create.df(V_matrix)\n    C_mi <- calc.Cmi_index(V_polygon, Area_polygon)\n    return(C_mi)\n}\n\n\n##Add a column of C_mi indexes to the polygon dataframe\nSPDF.Cmi_Index <- function(spdf){\n    n <- length(spdf@polygons)\n    polygons.areas <- extract.areas(spdf)\n    Cmi_indexes <- rep(0, n)\n    for(i in 1:n){\n        Cmi_indexes[i] <- Polygon.Cmi_index(spdf, i)\n    }\n    spdf@data$C_mi <- Cmi_indexes\n    return(spdf)\n}\n\n\n",
    "created" : 1450881895405.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2547500656",
    "id" : "1ED0E26E",
    "lastKnownWriteTime" : 1450879227,
    "path" : "~/CLOUD/C07_UCL_SmartCities/GIS/GIS_Coursework/00_Code/FUN_SPDF_Cmi_Index.R",
    "project_path" : "FUN_SPDF_Cmi_Index.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}